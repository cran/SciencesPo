---
title: "Introduction to the SciencesPo Package"
author: "Daniel Marcelino"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_vignette:
    fig_width: 6
vignette: >
  %\VignetteIndexEntry{Introduction to SciencesPo}
   %\VignetteEngine{knitr::rmarkdown}
    \usepackage[T1]{fontenc}
     \usepackage[utf8]{inputenc}
---
  
  To call in the statistician after the experiment is done may be no more than asking him to perform a post-mortem examination: he may be able to say what the experiment died of. ~ Sir Ronald Aylmer Fisher
The plural of anecdote is not data. ~ Roger Brinner
The combination of some data and an aching desire for an answer does not ensure that a reasonable answer can be extracted from a given body of data. ~ John Tukey

# Overview
The **SciencesPo** package is meant to provide algorithms and functions for analyzing political behavior data, including measures of political fragmentation and seats allocation. In addition, it also offers built-in functions for descriptive statistics, tests, tables, and pre set publication-ready plots and themes for **ggplot2**, which will require only a minimum amount of fiddling with sizes and labels, etc. The package is intended to give students and postdocs an easy way of making the most of their data--usually small datasets. Although this package is available for the general public, it meets my personal needs and tastes. Yours may be different.

You can find the package source on [Github](https://github.com/danielmarcelino/SciencesPo), and you are welcome to contribute code via pull requests, or file feature requests and bug reports via [Github issues](https://github.com/danielmarcelino/SciencesPo/issues).

# Learning by doing
This vignette builds on the examples scattered through the package's manual available on [https://cran.r-project.org](https://cran.r-project.org/web/packages/SciencesPo/SciencesPo.pdf). This first example walks through setting up **SciencesPo** for conducting basic data analysis.


## Loading and Unloading *SciencesPo*
```{r echo=TRUE, message=FALSE, comment=NA}
library(SciencesPo)


## Do things 


detach("package:SciencesPo", unload=TRUE)


#You can also use the unloadNamespace command,

unloadNamespace("SciencesPo")

```


## Search results from help.search()
Here are some examples demonstrating the results of help.search(), or you can also use ?? to search for a string.

```{r echo=TRUE, message=FALSE}
help.search('bar.plot')


help.search('twoway', package = 'SciencesPo')
```


## Vignette and dataset lists
To see the existing vignettes, type: 
```{r echo=TRUE, message=FALSE}
vignette(package = "SciencesPo")
```

To see the collection of data included in the package, type:
```{r echo=TRUE, message=FALSE}
data(package = "SciencesPo")
```


## Example of printing objects
Whenever you load the package, it will setup its own environment, including the plotting theme. Thus, some objects may be printed or plotted differently with what you would have seen in a normal R console. To not use the default settings of the package, you can use `getOption()` to see what defaults are, and change them accordingly. 

## Exploratory data functions

### Computing the Skewness and Kurtosis of the Data
This function performs three types of skewness tests:
```{r echo=FALSE, message=FALSE}
require(SciencesPo)

set.seed(51)
 w <-sample(4,10, TRUE)
 x <- sample(10, 1000, replace=TRUE, prob=w)
 
skewness(x, type = 1);
kurtosis(x, type = 1);
skewness(x); # Type 2 is the default 
kurtosis(x); # Type 2 is the default 
skewness(x, type = 3);
kurtosis(x, type = 3);

```


### Standard Error and Confidence Interval

To demonstrate the output of these functions, below are the ages of the Presidents of the United States at the time of their inaugurations.

```{r pres-ages, echo=TRUE, message=FALSE, cache=TRUE}
pres =c(42,43,46,46,47,48,49,49,50,51,51,51,51,51,52,52,54,54,54,54,54,55,55,55,55,56,56,56,57,57,57,57,58,60,61,61,61,62,64,64,65,68,69)

ci(pres, level=.95) # confidence interval

ci(pres, level=.95)@mean # confidence interval

se(pres) # std. error
```


### Average Absolute Deviation and Winsorized Mean
```{r echo=FALSE, message=FALSE}
aad(pres) 


winsorize(pres)
```


# Data Manipulation


## `safe.chars`
By default, R converts character columns to factors. Instead of re-reading the data using \code{stringsAsFactors=FALSE}, the \code{\link{safe.chars}} function identifies which columns are currently factors, and convert them all to characters parsing the levels as strings.

```{r echo=FALSE, message=FALSE}
require(SciencesPo)
str(iris)

iris_2 = safe.chars(iris)

str(iris_2)
```


## `destring`
This function converts factor variables to numeric, much like the way Stata does.
```{r echo=TRUE, message=FALSE}
require(SciencesPo)

mylevels <- c('Strongly Disagree', 
              'Disagree', 
              'Neither', 
              'Agree', 
              'Strongly Agree')

myvar <- factor(sample(mylevels[1:5], 10, replace=TRUE))
```


As we can see, this vector is un(ordered) in a "strange" way so to reflect the meaning of the levels I've attributed:
```{r echo=TRUE, message=FALSE}
unclass(myvar) # testing the order
```

By `destring` this, we should get a numeric result with the same (un)order:
```{r echo=TRUE, message=FALSE}
destring(myvar) 
```

## `rounded`
It's rather common to use numbers without leading zeros. The `rounded` function does just that. Isn't fancy?

```{r echo=TRUE, message=FALSE}
 (x = seq(0, 1, by=.1))
 rounded(x) 
```


# Tables
There is a specific document covering one-way, two-way, and multiway tabulations with accompanying independent tests. 

To tabulate on variable's responses, simply:

```{r one-way, eval=FALSE, echo=TRUE, message=FALSE, comment=NA}
CrossTabs(titanic$SURVIVED) 
```

A more performant descriptive output can be obtained with the `Freq` command, which resembles the *SPSS* output. 

```{r Freq, echo=TRUE, message=FALSE, comment=NA}
Frequency(titanic, SURVIVED) 
```

To add a second, for a cross-tabulation:

```{r two-way, echo=TRUE, message=FALSE}
crosstable(titanic, SEX, CLASS, SURVIVED) 
```

To delete table entries that are less relevant, switch it to `FALSE`. And switch it to `TRUE` to add table entries that relevant. For instance, the `chisq` argument refers to a Chi-Square test of Independence, to calculate the test, switch it to `TRUE`.


# Distributions 

## `uniform`

# Political Behavior Measures

## Political Diversity Indices

```{r politicalDiversity1, echo=TRUE, message=FALSE}
library("SciencesPo")

# The 1980 presidential election in the US (vote share):

(US1980 <- c("Democratic"=0.410, "Republican"=0.507,
              "Independent"=0.066, "Libertarian"=0.011,
              "Citizens"=0.003, "Others"=0.003));

politicalDiversity(US1980); # ENEP (laakso/taagepera) method 

politicalDiversity(US1980, index= "golosov");

```

Considers the following `data.frame` with electoral results for the 1999 election in Helsinki, the seats were allocated using both the Saint-LaguÃ« and the D'Hondt methods: 

```{r Helsinki-election, echo=TRUE, message=FALSE}
# Helsinki's 1999

Helsinki <- data.frame(votes = c(68885, 18343, 86448, 21982, 51587,
                                 27227, 8482, 7250, 365, 2734, 1925,
                                 475, 1693, 693, 308, 980, 560, 590, 185),
                       seats.SL=c(5, 1, 6, 1, 4, 2, 1, 0, 0, 0, 0, 0, 0, 0,
                                  0, 0, 0, 0, 0),
                       seats.dH=c(5, 1, 7, 1, 4, 2, 0, 0, 0, 0, 0, 0, 0, 0,
                                  0, 0, 0, 0, 0))
```


```{r echo=TRUE, message=FALSE, comment=NA}
# politicalDiversity(Helsinki$votes); #ENEP Votes

politicalDiversity(Helsinki$seats.SL); #ENP for Saint-Lague

politicalDiversity(Helsinki$seats.dH); #ENP for D'Hondt
```

## Highest Averages Methods of Allocating Seats Proportionally

Now using data from 2014 Brazilian legislative elections, especifically from one district, let's compare the results from D'Hondt, Saint-Lague, Hungtinton-Hill, and Imperiali methods.

```{r Ceara-election, echo=TRUE, cache=TRUE}
# Results for the state legislative house of Ceara (2014):
Ceara <- c("PCdoB"=187906, "PDT"=326841,"PEN"=132531, "PMDB"=981096,
           "PRB"=2043217,"PSB"=15061, "PSC"=103679, "PSTU"=109830,
           "PTdoB"=213988, "PTC"=67145, "PTN"=278267)
```

The basic imputs for this class of functions are: 1) a list of parties, 2) a list of positive votes, and 3) a constant value for the number of seats to be returned. A numeric value (0~1) for the threshold is optional.

### d'Hondt

```{r highestAverages1, echo=TRUE, message=FALSE, comment=NA}
highestAverages(parties=names(Ceara), votes=Ceara,
                seats = 42, method = "dh") 
```

The d'Hondt method is only one way of allocating seats in party list systems. Other methods include the Saint-Lague, the modified Saint-Lague, the Danish version, Imperiali (do not to confuse with the Imperiali quota which is a Largest remainder method), and Hungtinton-Hill. 

### Saint-Lague

```{r echo=TRUE, message=FALSE, comment=NA}
highestAverages(parties=names(Ceara), votes=Ceara,
                seats = 42, method = "sl") 
```

### Hungtinton-Hill

```{r echo=TRUE, message=FALSE, comment=NA}
highestAverages(parties=names(Ceara), votes=Ceara, 
                seats = 42, method = "hh") 
```

### Imperiali

```{r echo=TRUE, message=FALSE, comment=NA}
highestAverages(parties=names(Ceara), votes=Ceara, 
                seats = 42, method = "imperiali") 
```

### Using thresholds

Let's assume the electoral system has a 5\% vote threshold. Meaning that parties must get at least 5\% of the total unspoiled votes cast in order to participate in the distribution of seats. Parties *PCdoB*, *PTdoB*, *PEN*, *PSC*, *PSTU*, *PSB*, and *PTC* would then be elimiated from competition at the outset. If the d'Hondt method of seat allocation were employed, then party *PRB* would get 4 extra seats than otherwise, and party *PMDB* 3 additional seats.

```{r echo=TRUE, message=FALSE, comment=NA}
highestAverages(parties=names(Ceara), votes=Ceara,
               seats = 42, method = "dh", threshold = 5/100) 
```

Other methods divide the votes by a mathematically derived quota, such as the Droop quota, the Hare quota (or Hamilton/Vinton), or the Imperiali quota, see next. 


## Largest Remainder Methods of Allocating Seats Proportionally

### Hare quota

```{r eval=FALSE, echo=TRUE, message=FALSE, comment=NA}
largestRemainders(parties=names(Ceara), votes=Ceara, 
                seats = 42, method = "hare") 
```

### Droop quota

```{r eval=FALSE, echo=TRUE, message=FALSE, comment=NA}
largestRemainders(parties=names(Ceara), votes=Ceara, 
                seats = 42, method = "droop") 
```

### Imperiali quota
 
```{r data-Italy, eval=FALSE, echo=TRUE, message=FALSE}

# The 1946 Italian Constituent Assembly election results: parties and unspoilt votes

Italy = data.frame(party=c("DC", "PSIUP", "PCI", "UDN", "UQ", "PRI",
                            "BNL", "PdA", "MIS", "PCd'I", "CDR",
                           "PSd'Az", "MUI", "PCS", "PDL", "FDPR"),
                   votes=c(8101004, 4758129, 4356686, 1560638,	1211956,
                           1003007, 637328, 334748, 171201, 102393,
                           97690, 78554, 71021, 51088, 40633, 21853))
```


```{r eval=FALSE, echo=TRUE, message=FALSE, comment=NA}
with(Italy, largestRemainders(parties=party, votes=votes, 
                seats = 556, method = "imperiali.q") )
```


## Suitable output for recycling in RMarkdown documents 

The output produced by the `highestAveragesof()` and `largestRemainders()`  functions is always a `data.frame`; therefore, it's very straightforward  to use with other aplications. For instance, I like the idea of using the output with the **knitr** package to produce publishable-quality tables, or graphs with **ggplot2**.


```{r echo=TRUE, message=FALSE, comment=NA}
mytable = highestAverages(parties=names(Ceara), votes=Ceara, 
                seats = 42, method = "dh") 

library(knitr)

kable(mytable, align=c("l","c","c"))
```



```{r echo=TRUE, message=FALSE, fig.width=4.5, fig.height=4.5, fig.align="center", fig.cap= "2014 Legislative Election in Ceara (M=42)"}

mytable = highestAverages(parties=names(Ceara), votes=Ceara, 
                seats = 42, method = "dh") 

p <- ggplot(mytable, aes(x=reorder(Party, Seats), y=Seats)) + 
  geom_bar(position="dodge", stat = "identity") +
  coord_flip() + labs(x="", y="# Seats")
p + theme_grey() 
```


# Exploratory Statistical Tests


# Plot Design

The default **ggplot2** design has its charm, in my opinion. But, very often I don't like the gray background grid, particularly when I'm preparing academic papers because I feel it distracts from the data. For example, see this **ggplot2** visualization of the following plot:

```{r eval=TRUE}
detach("package:SciencesPo")

ggplot(mtcars, aes(mpg, disp,color=factor(carb),size=hp)) + geom_point(alpha=0.7) + labs(title="Bubble Plot") + scale_size_continuous(range = c(3,10))

qplot(1:3, 1:3)
```

I rather prefer a clean layout for publication. Starting with simple layouts is better because we can add things as we need rather than taking them away. Thus, by default, the `theme_pub` prints a plot without background and minor grid lines. Also, if a legend is needed, it will appear underneath of the plot rather than on the right side.

```{r eval=TRUE}
require(SciencesPo)
qplot(1:3, 1:3)
```

There's a complete discussion of plot design in the outstanding reference [Cookbook for R](http://www.cookbook-r.com/Graphs/Legends_%28ggplot2%29/) that might be of your interest.

## Changing defaults 
If you want to change the theme for an entire session you can use `theme_set()` as in `theme_set(theme_gray())` to switch to default **ggplot2** theme for all subsequent plots. Otherwise, you may also apply themes without changing the default setup as of `plot + theme_gray()`. 

To modify general aspects of the `theme_pub()` as fontsize, font family etc:

```{r echo=FALSE, message=FALSE}
require(SciencesPo)
theme_set(theme_pub(font_size=12)) # default fontsize doesn't work well for online viewing
qplot(1:3, 1:3)
```


The default fontfamily used in the theme is "Helvetica", but it is easy to chane to another style: 
```{r echo=FALSE, message=FALSE}
require(SciencesPo)
# "Verdana", "serif" and "sans" are also high-readability fonts
theme_set(theme_pub(font_size=12, font_family = "Consolas")) 
qplot(1:3, 1:3)
```

Modify it with theme()
```{r echo=FALSE, message=FALSE}
prefs <- theme(axis.text = element_text(size=14, colour=NULL))

qplot(1:3, 1:3) + prefs
```



```{r echo=FALSE, message=FALSE}
# Modifying a theme function
themeMod <- theme_gray() +
  theme(text = element_text(family = "Times", colour = "blue", size = 14))

ggplot(mpg, aes(x = cty, y = hwy, colour = factor(cyl))) + 
   geom_point(size = 2.5)
```


You might be able to put the legend inside the plot area, using:
  
line_plot + theme(legend.justification=c(1,0), legend.position=c(1,0))

This positions the legend inside the plot area, at the bottom-right. You can also put the legend at the top or bottom of the plot using, e.g.:
  
line_plot + theme(legend.position="bottom")


```{r echo=FALSE, message=FALSE}
# Only change the 'colour' property of theme element 'text'

mytheme1 <- theme_grey() + theme(text = element_text(colour="red"))
mytheme1$text
```


```{r echo=FALSE, message=FALSE}
# Replace the 'text' element entirely
mytheme2 <- theme_grey() %+replace% theme(text = element_text(colour="red"))
mytheme2$text
```

By default, **SciencesPo** disables grid lines on the plot. In many cases, this is the cleanest and most elegant way to display the data. However, sometimes gridlines may be useful, and thus **SciencesPo** provides a simple way of adding gridlines, via the function `background_grid()`:

```{r eval=FALSE, message=FALSE}
plot.mpg + background_grid(major = "xy", minor = "none")
```

While the same result could be obtained using the function `theme()`, the function `background_grid()` makes the most commonly used option easily accessible. See the reference documentation for details.

# Generic plot annotations

Finally, the `draw_plot()` function also allows us to place graphs at arbitrary locations and at arbitrary sizes onto the canvas. This is useful for combining subplots into a layout that is not a simple grid, e.g. with one sub-plot spanning the entire width of the figure and two other figures using up half of the figure width:

```{r eval=FALSE, message=FALSE, fig.width=7, fig.height=5}

plot.iris <- ggplot(iris, aes(Sepal.Length, Sepal.Width)) + 
  geom_point() + facet_grid(. ~ Species) + stat_smooth(method = "lm") +
  background_grid(major = 'y', minor = "none") + # add thin horizontal lines 
  panel_border() # and a border around each panel
# plot.mpg and plot.diamonds were defined earlier
ggdraw() +
  draw_plot(plot.iris, 0, .5, 1, .5) +
  draw_plot(plot.mpg, 0, 0, .5, .5) +
  draw_plot_label(c("A", "B", "C"), c(0, 0, 0.5), c(1, 0.5, 0.5), size = 15)
```


The functions `background_grid()` and `panel_border()` are convenience functions defined by **SciencesPo** to save some typing when manipulating the background grid and panel border. 

```{r eval=FALSE, echo=FALSE, message=FALSE, fig.width=7, fig.height=5}
# Of course, we can also go crazy:
ggdraw() +
  #geom_rect(data = boxes, aes(xmin = x, xmax = x + .15, ymin = y, ymax = y + .15),
  #          colour = "gray60", fill = "red", alpha=.03) +
  geom_path(data = spiral, aes(x = x, y = y, colour = t), size = 6, alpha = .4) +
  draw_plot(plot.mpg, .3, .3, .4, .4) +
  draw_plot(plot.iris, 0, .7, .7, .35 ) +
  draw_plot(plot.iris, .45, .0, .6, .3 )
```

## Annotations underneath plots

The function `geom_foot()` can be used to add text as a plot footnote. To demonstrate its use, we first draw a plot, then add the footnote: 

```{r height.matters, fig.width=7, fig.height=5}
theme_set(theme_pub())

# Generating a ratio winner/opponent measure 
Presidents = transform(Presidents, 
                       height_ratio = winner.height/opponent.height) 

# Avoid missing data
Presidents <- subset(Presidents, !is.na(height_ratio))

fit=lm(winner.vote~height_ratio,data=Presidents)

mylabel=lm2eqn("Presidents","height_ratio","winner.vote")

p1 <- ggplot(Presidents, aes(x=height_ratio, y=winner.vote)) +
      geom_smooth(method=lm, colour="red", fill="gold")+
      geom_point(size = 5, alpha = .7) +
      annotate(geom = 'text', x = 1.1, y = 70, size = 5, label = mylabel, fontface = 'italic') +
      xlim(0.85,1.2) + ylim(25, 70) +
      xlab("Winner/Opponent Height Ratio") + 
      ylab("Relative Support for the Winner")
p1 

geom_foot("Draft Analysis, 2015", color = fade("brown1"))

```

